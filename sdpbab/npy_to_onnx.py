"""
Loads the weights, biases and layer information from the exported numpy files obtained from either the original
checkpoints of the network files provided by the Raghunathan paper or the files obtained from converting a .pb model to
numpy. A VeriNetNN network is then built from that information and stored as an onnx file.
"""

import numpy as np
import os
import torch
from verinet.neural_networks.verinet_nn import VeriNetNN, VeriNetNNNode

path = "self_trained_2_50_0.05"  # either self_trained_2_50_0.05 for Jianglin's self-trained network or "small_mnist"
# the networks from the Raghunathan paper
net_name = "self_trained_mnist"  # either one of self_trained_mnist for Jianglin's self-trained MNIST network or one of nips_lp,
# nips_pgd, nips_sdp (Raghunathan paper)

net_layer_types = np.load(os.path.join(path, "numpy", net_name + "_layers.npy"))

net_weights = []
net_biases = []
for i in range(len(net_layer_types)):
    net_weights.append(np.load(os.path.join(path, "numpy", net_name + "_w_" + str(i) + ".npy")))
    net_biases.append(np.load(os.path.join(path, "numpy", net_name + "_b_" + str(i) + ".npy")))

print(net_layer_types)
print([w.shape for w in net_weights])
print([b.shape for b in net_biases])

# Create VeriNetNN model
nodes = []
index = 0
nodes.append(VeriNetNNNode(index, torch.nn.Identity(), [], [index+1]))
index += 1
for i in range(len(net_layer_types)):
    if net_layer_types[i] == "ff_relu":
        new_op = torch.nn.Linear(net_weights[i].shape[1], net_weights[i].shape[0])
        with torch.no_grad():
            new_op.weight = torch.nn.Parameter(torch.tensor(net_weights[i]))
            new_op.bias = torch.nn.Parameter(torch.tensor(net_biases[i]))
        nodes.append(VeriNetNNNode(index, new_op, [index-1], [index+1]))
        index += 1
        nodes.append(VeriNetNNNode(index, torch.nn.ReLU(), [index-1], [index+1]))
        index += 1
    elif net_layer_types[i] == "ff":
        new_op = torch.nn.Linear(net_weights[i].shape[1], net_weights[i].shape[0])
        with torch.no_grad():
            new_op.weight = torch.nn.Parameter(torch.tensor(net_weights[i]))
            new_op.bias = torch.nn.Parameter(torch.tensor(net_biases[i]))
        nodes.append(VeriNetNNNode(index, new_op, [index-1], [index+1]))
        index += 1
    else:
        raise NotImplementedError("Processing for layer " + str(i) + " of type " + net_layer_types[i] +
                                  " not implemented")
nodes.append(VeriNetNNNode(index, torch.nn.Identity(), [index-1], []))

model = VeriNetNN(nodes)
print(model)

# Save model to onnx
# model.save requires a dummy tensor with the same shape as the inputs to the network --> generated by torch.randn()

# model.save(torch.randn(1, net_weights[0].shape[1]), os.path.join(path, net_name + ".onnx"))
